<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>B.O.S. v1</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap"
    rel="stylesheet"
  />
  <style>
    /* (keep your existing CSS exactly as-is) */
  </style>
</head>
<body>
  <!-- (boot screen + main content unchanged) -->

  <script>
    // 1) boot ‚Üí main fade (unchanged)
    window.addEventListener('DOMContentLoaded', () => {
      const boot = document.getElementById('boot-screen');
      const main = document.getElementById('main-content');
      setTimeout(() => {
        boot.classList.add('fade-out');
        boot.addEventListener('transitionend', () => {
          boot.style.display = 'none';
          main.classList.add('fade-in');
        }, { once: true });
      }, 3000);
    });

    // grab DOM nodes (unchanged)
    const chatLog = document.getElementById('chat-log');
    const input   = document.getElementById('user-input');
    const btn     = document.getElementById('send-btn');
    const orb     = document.getElementById('visualizer');
    const tts     = document.getElementById('tts-player');

    // TTS orb animation (unchanged)
    tts.addEventListener('play',  () => orb.classList.add('speaking'));
    tts.addEventListener('ended', () => orb.classList.remove('speaking'));

    // sendMessage (unchanged)
    async function sendMessage() {
      const text = input.value.trim();
      if (!text) return;
      chatLog.innerHTML += `<div class="you"><strong>You:</strong> ${text}</div>`;
      chatLog.scrollTop = chatLog.scrollHeight;
      input.value = '';
      let res = await fetch('/api/message',{ method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ text })
      });
      const { reply } = await res.json();
      chatLog.innerHTML += `<div class="bos"><strong>BOS:</strong> ${reply}</div>`;
      chatLog.scrollTop = chatLog.scrollHeight;
      res = await fetch('/api/speak',{ method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ text: reply })
      });
      const { url } = await res.json();
      tts.src = url; tts.play();
    }
    btn.addEventListener('click', sendMessage);
    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') sendMessage();
    });

    // ‚Üê‚Äî‚Äî UPDATED RECORD/STOP LOGIC BELOW ‚Äî‚Äî‚Üí
    const recordBtn = document.getElementById('record-btn');
    let mediaRecorder, audioChunks = [], isRecording = false;

    recordBtn.addEventListener('click', async () => {
      if (!isRecording) {
        // 1Ô∏è‚É£ Pick a supported audio-only mimeType
        let mimeType = '';
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mimeType = 'audio/webm;codecs=opus';
        } else if (MediaRecorder.isTypeSupported('audio/webm')) {
          mimeType = 'audio/webm';
        } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
          mimeType = 'audio/ogg;codecs=opus';
        } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
          mimeType = 'audio/mp4';
        } else {
          console.error('‚ùå No suitable audio MIME type supported');
          return;
        }

        console.log('‚ñ∂Ô∏è Starting recording with', mimeType);
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];

        mediaRecorder.addEventListener('dataavailable', e => {
          console.log('üóÇÔ∏è Chunk:', e.data.type, e.data.size, 'bytes');
          audioChunks.push(e.data);
        });

        mediaRecorder.addEventListener('stop', async () => {
          const ext = mimeType.includes('mp4') ? 'mp4'
                    : mimeType.includes('ogg') ? 'ogg' : 'webm';
          const blob = new Blob(audioChunks, { type: mimeType });
          console.log(`‚èπÔ∏è Stopped. Sending voice.${ext} (${blob.size} bytes, type=${blob.type})`);

          const form = new FormData();
          form.append('file', blob, `voice.${ext}`);

          try {
            const res = await fetch('/api/transcribe', { method:'POST', body: form });
            console.log('üñ•Ô∏è Whisper status:', res.status);
            const json = await res.json();
            console.log('üî§ Whisper response:', json);
            if (json.text) input.value = json.text;
          } catch (err) {
            console.error('‚ùå Fetch error:', err);
          }
        });

        mediaRecorder.start();
        recordBtn.textContent = '‚èπ Stop';
        isRecording = true;

      } else {
        console.log('‚èπÔ∏è Stopping recording‚Ä¶');
        mediaRecorder.stop();
        recordBtn.textContent = 'üé§ Record';
        isRecording = false;
      }
    });
    // ‚Üê‚Äî‚Äî END RECORD/STOP LOGIC ‚Äî‚Äî‚Üí
  </script>
</body>
</html>
