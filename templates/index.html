<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>H.E.C.T.O.R v1</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap"
    rel="stylesheet"
  />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: #000; color: #fff;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
    }
    /* BOOT SCREEN */
    #boot-screen {
      position: fixed; inset: 0;
      background: #000;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 1000;
      opacity: 1;
      transition: opacity 1s ease-out;
    }
    #boot-screen.fade-out { opacity: 0; }
    #boot-screen img {
      /* Increase boot GIF size by 20% */
      width: 72vw;
      max-width: 720px;
      height: auto;
      display: block;
    }
    #boot-text {
      margin-top: 1rem; font-size: 1.5rem; color: #fff;
    }

    /* MAIN APP (hidden until boot done) */
    #main-content {
      position: relative;
      display: none; /* will switch to flex */
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      height: 100%; width: 100%;
      padding: 2rem 0;
      opacity: 0;
      transition: opacity 1s ease-in;
    }
    #main-content.fade-in {
      display: flex; opacity: 1;
    }

    /* HEADER */
    h1 {
      font-size: 3rem;
      color: #fff;
      text-shadow: 0 0 12px #fff;
    }

    /* VISUALIZER */
    #visualizer {
      width: 140px; height: 140px;
      border-radius: 50%;
      overflow: hidden;
      transition: transform 0.2s ease-out;
      margin-bottom: 1rem;
    }
    #visualizer.speaking {
      animation: heartbeat 1s ease-in-out infinite;
    }
    @keyframes heartbeat {
      0%,40%,100% { transform: scale(1); }
      10% { transform: scale(1.2); }
      30% { transform: scale(1.15); }
    }

    /* CHAT LOG */
    #chat-log {
      width: 80%; max-width: 600px;
      background: #111;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 1rem;
      flex: 1;
      overflow-y: auto;
      margin-bottom: 1rem;
    }
    #chat-log div { margin-bottom: .5rem; }
    .you { color: #0af; }
    .hector { color: #fff; }

    /* INPUT CONTROLS */
    #controls {
      width: 80%; max-width: 600px;
      display: flex; margin-bottom: 1rem;
    }
    #user-input {
      flex: 1;
      padding: .75em;
      border: none;
      border-radius: 6px 0 0 6px;
      background: #111;
      color: #fff;
      outline: none;
      font-size: 1em;
    }
    #send-btn {
      padding: 0 .75em;
      background: #fff;
      color: #000;
      border: none;
      border-radius: 0 6px 6px 0;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.2s ease;
    }
    #send-btn:hover { background: #ddd; }

    /* RECORD & CONVERSATION BUTTONS */
    #record-btn,
    #conversation-btn {
      margin-left: .5rem;
      padding: 0 .75em;
      background: #222;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.2s ease;
    }
    #record-btn:hover,
    #conversation-btn:hover { background: #333; }

    /* EMAIL FORM */
    #email-form {
      width: 80%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      margin-bottom: 1rem;
    }
    #email-form input,
    #email-form textarea {
      margin-bottom: .5rem;
      padding: .5em;
      background: #111;
      color: #fff;
      border: 1px solid #333;
      border-radius: 6px;
      font-size: 1em;
    }
    #send-email-btn {
      padding: .5em;
      background: #fff;
      color: #000;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.2s ease;
    }
    #send-email-btn:hover { background: #ddd; }
  </style>
</head>
<body>

  <!-- BOOT SCREEN -->
  <div id="boot-screen">
    <img src="{{ url_for('static', filename='boot.gif') }}" alt="H.E.C.T.O.R Boot Sequence" />
    <div id="boot-text">Initializing H.E.C.T.O.R...</div>
    <audio id="boot-audio" src="{{ url_for('static', filename='boot.wav') }}" autoplay style="display:none;"></audio>
  </div>

  <!-- MAIN APP -->
  <div id="main-content">
    <h1>H.E.C.T.O.R</h1>

    <img id="visualizer"
         src="{{ url_for('static', filename='orb.gif') }}"
         alt="H.E.C.T.O.R speaking visualizer" />

    <div id="chat-log"></div>

    <div id="controls">
      <input id="user-input" type="text" placeholder="Type a message‚Ä¶" />
      <button id="send-btn">Send</button>
      <button id="record-btn">üé§ Record</button>
        <button id="conversation-btn">üí¨ Converse</button>
      </div>

      <form id="email-form">
        <input id="email-to" type="email" placeholder="Recipient" required />
        <input id="email-subject" type="text" placeholder="Subject" required />
        <textarea id="email-body" placeholder="Body" required></textarea>
        <button id="send-email-btn" type="submit">Send Email</button>
      </form>

      <audio id="tts-player" style="display:none;"></audio>
    </div>

  <script>
    // BOOT ‚Üí MAIN
    const boot = document.getElementById('boot-screen');
    const main = document.getElementById('main-content');
    const bootAudio = document.getElementById('boot-audio');

    function transitionToMain() {
      if (boot.classList.contains('fade-out')) return;
      boot.classList.add('fade-out');
      boot.addEventListener('transitionend', () => {
        boot.style.display = 'none';
        main.classList.add('fade-in');
      }, { once: true });
    }

    bootAudio.addEventListener('ended', transitionToMain);
    bootAudio.play().catch(err => {
      console.warn('Boot audio failed:', err);
      transitionToMain();
    });

    // CHAT & TTS
    const chatLog = document.getElementById('chat-log');
    const input   = document.getElementById('user-input');
    const btn  = document.getElementById('send-btn');
    const orb  = document.getElementById('visualizer');
    const tts  = document.getElementById('tts-player');

    // EMAIL FORM ELEMENTS
    const emailForm    = document.getElementById('email-form');
    const emailTo      = document.getElementById('email-to');
    const emailSubject = document.getElementById('email-subject');
    const emailBody    = document.getElementById('email-body');

    function appendMessage(cls, label, text) {
      const div = document.createElement('div');
      div.className = cls;
      const strong = document.createElement('strong');
      strong.textContent = label;
      div.appendChild(strong);
      div.appendChild(document.createTextNode(' ' + text));
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Track when H.E.C.T.O.R is speaking to ignore microphone input
    let ignoreRecognition = false;
    let discardChunk      = false;

    tts.addEventListener('play', () => {
      orb.classList.add('speaking');
      ignoreRecognition = true;
      discardChunk      = true;

      if (isConversing) {
        if (recognition) {
          recognition.stop();
        } else if (convoRecorder && convoRecorder.state === 'recording') {
          convoRecorder.stop();
        }
      }
    });

    tts.addEventListener('ended', () => {
      orb.classList.remove('speaking');
      ignoreRecognition = false;
      discardChunk      = false;

      if (isConversing) {
        if (recognition) {
          recognition.start();
        } else if (convoRecorder && convoRecorder.state !== 'recording') {
          startChunk();
        }
      }
    });

    async function sendMessage(txt) {
      let text = typeof txt === 'string' ? txt.trim() : input.value.trim();
      if (!text) return;
      const cleaned = text.replace(/\s+/g, "");
      if (/^\.*$/.test(cleaned)) {
        console.log('Ignoring dot-only input');
        input.value = '';
        return;
      }
      appendMessage('you', 'You:', text);
      input.value = '';
      let res = await fetch('/api/message', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ text })
      });
      const { reply } = await res.json();
      appendMessage('hector', 'H.E.C.T.O.R:', reply);
      res = await fetch('/api/speak', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ text: reply })
      });
      const { url } = await res.json();
      tts.src = url; tts.play();
    }

    btn.addEventListener('click', sendMessage);
    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') sendMessage();
    });

    // EMAIL FORM SUBMISSION
    emailForm.addEventListener('submit', async e => {
      e.preventDefault();
      const payload = {
        to: emailTo.value.trim(),
        subject: emailSubject.value.trim(),
        body: emailBody.value.trim(),
      };
      try {
        const res = await fetch('/api/email/send', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) {
          appendMessage('hector', 'H.E.C.T.O.R:', `Email error: ${data.error || res.statusText}`);
        } else {
          appendMessage('hector', 'H.E.C.T.O.R:', 'Email sent.');
          emailForm.reset();
        }
      } catch (err) {
        appendMessage('hector', 'H.E.C.T.O.R:', `Email error: ${err}`);
      }
    });

    // RECORD / STOP ‚Üí WHISPER
    const recordBtn = document.getElementById('record-btn');
    let mediaRecorder, audioChunks = [], isRecording = false;

    recordBtn.addEventListener('click', async () => {
      if (!isRecording) {
        // pick MP3 if supported, else WebM/Opus
        const useMp3 = MediaRecorder.isTypeSupported('audio/mpeg');
        const mimeType = useMp3 ? 'audio/mpeg' : 'audio/webm;codecs=opus';
        console.log('‚ñ∂Ô∏è Recording with', mimeType);

        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: true }
        });
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];

        mediaRecorder.addEventListener('dataavailable', e => {
          console.log('üóÇ Chunk:', e.data.type, e.data.size, 'bytes');
          audioChunks.push(e.data);
        });

        mediaRecorder.addEventListener('stop', async () => {
          // wrap into a File so Whisper sees correct type
          const blob = new Blob(audioChunks, { type: mimeType });
          console.log('‚èπÔ∏è Raw blob.type:', blob.type);
          const ext = useMp3 ? 'mp3' : 'webm';
          const file = new File([blob], `voice.${ext}`, { type: blob.type });

          const form = new FormData();
          form.append('file', file);

          const url = `${window.location.origin}/api/transcribe`;
          console.log('üì§ Sending file to', url);

          try {
            const res = await fetch(url, { method: 'POST', body: form });
            console.log('üñ•Ô∏è Whisper status:', res.status);
            const json = await res.json();
            console.log('üî§ Whisper says:', json);
            if (json.text) input.value = json.text;
          } catch (err) {
            console.error('‚ùå Whisper error:', err);
          }
        });

        mediaRecorder.start();
        recordBtn.textContent = '‚èπ Stop';
        isRecording = true;

      } else {
        console.log('‚èπÔ∏è Stopping recording');
        mediaRecorder.stop();
        recordBtn.textContent = 'üé§ Record';
        isRecording = false;
      }
    });

    // CONVERSATION MODE
    const convoBtn = document.getElementById('conversation-btn');
    const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
    const MR       = window.MediaRecorder || window.WebKitMediaRecorder;

    let recognition;
    let convoRecorder, convoStream, convoChunks = [], convoTimer;
    let isConversing = false;

    const CHUNK_MS = 5000; // 5 sec per segment

    function startChunk() {
      convoRecorder.start();
      convoTimer = setTimeout(() => {
        if (convoRecorder.state === 'recording') convoRecorder.stop();
      }, CHUNK_MS);
    }

    async function startFallback() {
      const useMp3  = MR && MR.isTypeSupported && MR.isTypeSupported('audio/mpeg');
      const mime    = useMp3 ? 'audio/mpeg' : 'audio/webm;codecs=opus';
      convoStream   = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: true }
      });
      convoRecorder = new MR(convoStream, { mimeType: mime });
      convoChunks   = [];

      convoRecorder.addEventListener('dataavailable', e => convoChunks.push(e.data));
      convoRecorder.addEventListener('stop', async () => {
        if (discardChunk) {
          convoChunks = [];
          if (isConversing) startChunk();
          return;
        }
        const blob = new Blob(convoChunks, { type: mime });
        const ext  = useMp3 ? 'mp3' : 'webm';
        const file = new File([blob], `convo.${ext}`, { type: blob.type });
        const form = new FormData();
        form.append('file', file);
        try {
          const res  = await fetch('/api/transcribe', { method: 'POST', body: form });
          const json = await res.json();
          if (json.text) sendMessage(json.text);
        } catch (err) {
          console.error('‚ùå Convo transcribe error:', err);
        }
        convoChunks = [];
        if (isConversing) startChunk();
      });

      startChunk();
    }

    function stopFallback() {
      clearTimeout(convoTimer);
      if (convoRecorder && convoRecorder.state === 'recording') convoRecorder.stop();
      if (convoStream) convoStream.getTracks().forEach(t => t.stop());
    }

    if (SpeechRec) {
      recognition = new SpeechRec();
      recognition.continuous = true;
      recognition.interimResults = false;

      recognition.addEventListener('result', e => {
        if (ignoreRecognition) return;
        const result = e.results[e.resultIndex][0].transcript;
        sendMessage(result);
      });

      recognition.addEventListener('end', () => {
        if (isConversing) recognition.start();
      });
    }

    if (!SpeechRec && !(MR && navigator.mediaDevices?.getUserMedia)) {
      convoBtn.disabled = true;
      convoBtn.title = 'Speech recognition not supported';
    }


    convoBtn.addEventListener('click', async () => {
        if (!isConversing) {
          isConversing = true;
          convoBtn.textContent = '‚èπ Stop Convo';
          if (recognition) {
            recognition.start();
          } else if (MR && navigator.mediaDevices?.getUserMedia) {
            await startFallback();
          } else {
            alert('Speech recognition not supported in this browser.');
            isConversing = false;
            convoBtn.textContent = 'üí¨ Converse';
          }
        } else {
          isConversing = false;
          convoBtn.textContent = 'üí¨ Converse';
          if (recognition) recognition.stop();
          else stopFallback();
        }
      });
  </script>
</body>
</html>
